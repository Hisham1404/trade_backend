"""
Portfolio Management API Router

Provides REST API endpoints for portfolio CRUD operations, holdings management,
transaction tracking, and performance analytics.
"""

from datetime import datetime, date
from typing import List, Optional, Dict, Any
from fastapi import APIRouter, Depends, HTTPException, Query, Path, BackgroundTasks
from fastapi.responses import JSONResponse
from sqlalchemy.orm import Session
from app.auth.jwt_handler import get_current_user
from app.database import get_db
from app.models.user import User
from app.schemas.portfolio import (
    PortfolioCreate, PortfolioUpdate, PortfolioResponse,
    PortfolioListResponse, PortfolioPerformance, PortfolioAnalytics,
    HoldingCreate, HoldingUpdate, HoldingResponse, HoldingListResponse,
    TransactionCreate, TransactionResponse, TransactionListResponse,
    PortfolioErrorResponse, TransactionType
)
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/portfolios",
    tags=["Portfolio Management"],
    responses={
        404: {"model": PortfolioErrorResponse, "description": "Portfolio not found"},
        403: {"model": PortfolioErrorResponse, "description": "Access denied"},
        422: {"model": PortfolioErrorResponse, "description": "Validation error"}
    }
)


# Portfolio CRUD Operations
@router.post("/", response_model=PortfolioResponse, status_code=201)
async def create_portfolio(
    portfolio_data: PortfolioCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Create a new portfolio for the authenticated user.
    
    Creates a portfolio with initial capital allocation and risk management settings.
    """
    try:
        # Mock implementation - in production, save to database
        portfolio_id = 1  # Would be generated by database
        
        portfolio_response = PortfolioResponse(
            id=portfolio_id,
            name=portfolio_data.name,
            description=portfolio_data.description,
            initial_capital=portfolio_data.initial_capital,
            current_value=portfolio_data.initial_capital,  # Initially equals initial capital
            cash_balance=portfolio_data.initial_capital,   # All cash initially
            invested_amount=0.0,                          # No investments yet
            total_pnl=0.0,                               # No profit/loss yet
            total_pnl_percentage=0.0,
            day_pnl=0.0,
            day_pnl_percentage=0.0,
            risk_tolerance=portfolio_data.risk_tolerance.value,
            benchmark=portfolio_data.benchmark,
            is_active=True,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        logger.info(f"Created portfolio {portfolio_id} for user {current_user.id}")
        return portfolio_response
        
    except Exception as e:
        logger.error(f"Failed to create portfolio: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={"error": "creation_failed", "message": f"Failed to create portfolio: {str(e)}"}
        )


@router.get("/", response_model=PortfolioListResponse)
async def list_portfolios(
    page: int = Query(1, ge=1, description="Page number"),
    per_page: int = Query(20, ge=1, le=100, description="Items per page"),
    is_active: Optional[bool] = Query(None, description="Filter by active status"),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    List all portfolios for the authenticated user with pagination.
    """
    try:
        # Mock data - in production, query from database
        mock_portfolios = [
            PortfolioResponse(
                id=1,
                name="Growth Portfolio",
                description="Long-term growth focused portfolio",
                initial_capital=100000.0,
                current_value=105500.0,
                cash_balance=15000.0,
                invested_amount=90500.0,
                total_pnl=5500.0,
                total_pnl_percentage=5.5,
                day_pnl=750.0,
                day_pnl_percentage=0.71,
                risk_tolerance="moderate",
                benchmark="NIFTY50",
                is_active=True,
                created_at=datetime(2024, 1, 15, 10, 0, 0),
                updated_at=datetime(2024, 1, 15, 16, 30, 0)
            ),
            PortfolioResponse(
                id=2,
                name="Conservative Portfolio",
                description="Low-risk stable income portfolio",
                initial_capital=50000.0,
                current_value=51250.0,
                cash_balance=25000.0,
                invested_amount=26250.0,
                total_pnl=1250.0,
                total_pnl_percentage=2.5,
                day_pnl=125.0,
                day_pnl_percentage=0.24,
                risk_tolerance="conservative",
                benchmark="NIFTY100",
                is_active=True,
                created_at=datetime(2024, 1, 10, 9, 0, 0),
                updated_at=datetime(2024, 1, 15, 16, 30, 0)
            )
        ]
        
        # Apply filters
        if is_active is not None:
            mock_portfolios = [p for p in mock_portfolios if p.is_active == is_active]
        
        # Apply pagination
        start_idx = (page - 1) * per_page
        end_idx = start_idx + per_page
        paginated_portfolios = mock_portfolios[start_idx:end_idx]
        
        return PortfolioListResponse(
            portfolios=paginated_portfolios,
            total_count=len(mock_portfolios),
            page=page,
            per_page=per_page
        )
        
    except Exception as e:
        logger.error(f"Failed to list portfolios: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={"error": "list_failed", "message": f"Failed to list portfolios: {str(e)}"}
        )


@router.get("/{portfolio_id}", response_model=PortfolioResponse)
async def get_portfolio(
    portfolio_id: int = Path(..., description="Portfolio ID"),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get detailed information for a specific portfolio.
    """
    try:
        # Mock implementation - in production, query from database
        if portfolio_id == 1:
            return PortfolioResponse(
                id=1,
                name="Growth Portfolio",
                description="Long-term growth focused portfolio",
                initial_capital=100000.0,
                current_value=105500.0,
                cash_balance=15000.0,
                invested_amount=90500.0,
                total_pnl=5500.0,
                total_pnl_percentage=5.5,
                day_pnl=750.0,
                day_pnl_percentage=0.71,
                risk_tolerance="moderate",
                benchmark="NIFTY50",
                is_active=True,
                created_at=datetime(2024, 1, 15, 10, 0, 0),
                updated_at=datetime(2024, 1, 15, 16, 30, 0)
            )
        else:
            raise HTTPException(
                status_code=404,
                detail={"error": "not_found", "message": f"Portfolio {portfolio_id} not found"}
            )
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get portfolio {portfolio_id}: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={"error": "fetch_failed", "message": f"Failed to fetch portfolio: {str(e)}"}
        )


@router.put("/{portfolio_id}", response_model=PortfolioResponse)
async def update_portfolio(
    portfolio_id: int,
    portfolio_data: PortfolioUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Update portfolio information and settings.
    """
    try:
        # Mock implementation - in production, update in database
        if portfolio_id != 1:
            raise HTTPException(
                status_code=404,
                detail={"error": "not_found", "message": f"Portfolio {portfolio_id} not found"}
            )
        
        return PortfolioResponse(
            id=1,
            name=portfolio_data.name or "Growth Portfolio",
            description=portfolio_data.description or "Long-term growth focused portfolio",
            initial_capital=100000.0,
            current_value=105500.0,
            cash_balance=15000.0,
            invested_amount=90500.0,
            total_pnl=5500.0,
            total_pnl_percentage=5.5,
            day_pnl=750.0,
            day_pnl_percentage=0.71,
            risk_tolerance=portfolio_data.risk_tolerance.value if portfolio_data.risk_tolerance else "moderate",
            benchmark=portfolio_data.benchmark or "NIFTY50",
            is_active=portfolio_data.is_active if portfolio_data.is_active is not None else True,
            created_at=datetime(2024, 1, 15, 10, 0, 0),
            updated_at=datetime.utcnow()
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to update portfolio {portfolio_id}: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={"error": "update_failed", "message": f"Failed to update portfolio: {str(e)}"}
        )


@router.delete("/{portfolio_id}", status_code=204)
async def delete_portfolio(
    portfolio_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Delete a portfolio and all associated data.
    
    This is a soft delete that marks the portfolio as inactive.
    """
    try:
        # Mock implementation - in production, soft delete in database
        if portfolio_id != 1:
            raise HTTPException(
                status_code=404,
                detail={"error": "not_found", "message": f"Portfolio {portfolio_id} not found"}
            )
        
        logger.info(f"Deleted portfolio {portfolio_id} for user {current_user.id}")
        return JSONResponse(status_code=204, content=None)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to delete portfolio {portfolio_id}: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={"error": "delete_failed", "message": f"Failed to delete portfolio: {str(e)}"}
        )


# Holdings Management
@router.get("/{portfolio_id}/holdings", response_model=HoldingListResponse)
async def get_portfolio_holdings(
    portfolio_id: int,
    include_closed: bool = Query(False, description="Include closed positions"),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get all holdings for a specific portfolio with PnL calculations.
    """
    try:
        # Mock implementation
        mock_holdings = [
            HoldingResponse(
                id=1,
                portfolio_id=portfolio_id,
                symbol="RELIANCE",
                quantity=100,
                average_price=2500.0,
                current_price=2550.0,
                total_value=255000.0,
                invested_amount=250000.0,
                unrealized_pnl=5000.0,
                unrealized_pnl_percentage=2.0,
                day_pnl=1000.0,
                day_pnl_percentage=0.39,
                segment="equity",
                exchange="NSE",
                last_updated=datetime.utcnow()
            ),
            HoldingResponse(
                id=2,
                portfolio_id=portfolio_id,
                symbol="TCS",
                quantity=50,
                average_price=3200.0,
                current_price=3180.0,
                total_value=159000.0,
                invested_amount=160000.0,
                unrealized_pnl=-1000.0,
                unrealized_pnl_percentage=-0.63,
                day_pnl=-500.0,
                day_pnl_percentage=-0.31,
                segment="equity",
                exchange="NSE",
                last_updated=datetime.utcnow()
            )
        ]
        
        portfolio_summary = {
            "total_holdings": len(mock_holdings),
            "total_value": sum(h.total_value for h in mock_holdings),
            "total_invested": sum(h.invested_amount for h in mock_holdings),
            "total_pnl": sum(h.unrealized_pnl for h in mock_holdings),
            "day_pnl": sum(h.day_pnl for h in mock_holdings)
        }
        
        return HoldingListResponse(
            holdings=mock_holdings,
            portfolio_summary=portfolio_summary,
            total_count=len(mock_holdings)
        )
        
    except Exception as e:
        logger.error(f"Failed to get holdings for portfolio {portfolio_id}: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={"error": "fetch_failed", "message": f"Failed to fetch holdings: {str(e)}"}
        )


# Transaction Management
@router.post("/{portfolio_id}/transactions", response_model=TransactionResponse, status_code=201)
async def create_transaction(
    portfolio_id: int,
    transaction_data: TransactionCreate,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Record a new transaction and update portfolio holdings.
    
    Automatically calculates position changes, average prices, and portfolio metrics.
    """
    try:
        # Calculate transaction amounts
        total_amount = transaction_data.quantity * transaction_data.price
        net_amount = total_amount + transaction_data.fees
        
        # Mock implementation
        transaction_response = TransactionResponse(
            id=1,
            portfolio_id=portfolio_id,
            symbol=transaction_data.symbol,
            transaction_type=transaction_data.transaction_type.value,
            quantity=transaction_data.quantity,
            price=transaction_data.price,
            total_amount=total_amount,
            fees=transaction_data.fees,
            net_amount=net_amount,
            exchange=transaction_data.exchange,
            order_id=transaction_data.order_id,
            notes=transaction_data.notes,
            timestamp=datetime.utcnow()
        )
        
        # Schedule background task to update holdings and portfolio metrics
        background_tasks.add_task(
            update_portfolio_metrics,
            portfolio_id,
            transaction_data.symbol,
            transaction_data.transaction_type,
            transaction_data.quantity,
            transaction_data.price
        )
        
        logger.info(f"Created transaction for portfolio {portfolio_id}: {transaction_data.symbol}")
        return transaction_response
        
    except Exception as e:
        logger.error(f"Failed to create transaction: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={"error": "creation_failed", "message": f"Failed to create transaction: {str(e)}"}
        )


@router.get("/{portfolio_id}/transactions", response_model=TransactionListResponse)
async def get_portfolio_transactions(
    portfolio_id: int,
    page: int = Query(1, ge=1, description="Page number"),
    per_page: int = Query(50, ge=1, le=200, description="Items per page"),
    symbol: Optional[str] = Query(None, description="Filter by symbol"),
    transaction_type: Optional[TransactionType] = Query(None, description="Filter by transaction type"),
    start_date: Optional[date] = Query(None, description="Start date filter"),
    end_date: Optional[date] = Query(None, description="End date filter"),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get transaction history for a portfolio with filtering and pagination.
    """
    try:
        # Mock implementation
        mock_transactions = [
            TransactionResponse(
                id=1,
                portfolio_id=portfolio_id,
                symbol="RELIANCE",
                transaction_type="buy",
                quantity=100,
                price=2500.0,
                total_amount=250000.0,
                fees=250.0,
                net_amount=250250.0,
                exchange="NSE",
                order_id="ORD123456",
                notes="Initial purchase",
                timestamp=datetime(2024, 1, 15, 10, 30, 0)
            ),
            TransactionResponse(
                id=2,
                portfolio_id=portfolio_id,
                symbol="TCS",
                transaction_type="buy",
                quantity=50,
                price=3200.0,
                total_amount=160000.0,
                fees=160.0,
                net_amount=160160.0,
                exchange="NSE",
                order_id="ORD123457",
                notes="Tech allocation",
                timestamp=datetime(2024, 1, 15, 11, 15, 0)
            )
        ]
        
        # Apply filters
        filtered_transactions = mock_transactions
        if symbol:
            filtered_transactions = [t for t in filtered_transactions if t.symbol == symbol.upper()]
        if transaction_type:
            filtered_transactions = [t for t in filtered_transactions if t.transaction_type == transaction_type.value]
        
        # Apply pagination
        start_idx = (page - 1) * per_page
        end_idx = start_idx + per_page
        paginated_transactions = filtered_transactions[start_idx:end_idx]
        
        return TransactionListResponse(
            transactions=paginated_transactions,
            total_count=len(filtered_transactions),
            page=page,
            per_page=per_page
        )
        
    except Exception as e:
        logger.error(f"Failed to get transactions for portfolio {portfolio_id}: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={"error": "fetch_failed", "message": f"Failed to fetch transactions: {str(e)}"}
        )


# Performance Analytics
@router.get("/{portfolio_id}/performance", response_model=PortfolioPerformance)
async def get_portfolio_performance(
    portfolio_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get comprehensive performance metrics for a portfolio.
    
    Includes PnL, risk metrics, and benchmark comparison.
    """
    try:
        # Mock implementation with realistic performance metrics
        performance = PortfolioPerformance(
            portfolio_id=portfolio_id,
            total_value=105500.0,
            total_pnl=5500.0,
            total_pnl_percentage=5.5,
            realized_pnl=2000.0,
            unrealized_pnl=3500.0,
            day_pnl=750.0,
            day_pnl_percentage=0.71,
            max_drawdown=-2.5,
            volatility=1.8,
            sharpe_ratio=1.15,
            beta=0.85,
            alpha=0.5
        )
        
        return performance
        
    except Exception as e:
        logger.error(f"Failed to get performance for portfolio {portfolio_id}: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={"error": "fetch_failed", "message": f"Failed to fetch performance: {str(e)}"}
        )


@router.get("/{portfolio_id}/analytics", response_model=PortfolioAnalytics)
async def get_portfolio_analytics(
    portfolio_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get detailed portfolio analytics including sector allocation and risk analysis.
    """
    try:
        # Mock implementation
        analytics = PortfolioAnalytics(
            portfolio_id=portfolio_id,
            sector_allocation={
                "Technology": 30.0,
                "Banking": 25.0,
                "Energy": 20.0,
                "Healthcare": 15.0,
                "Others": 10.0
            },
            market_cap_allocation={
                "Large Cap": 60.0,
                "Mid Cap": 25.0,
                "Small Cap": 15.0
            },
            concentration_risk="Low",
            top_contributors=[
                {"symbol": "RELIANCE", "contribution": 1250.0},
                {"symbol": "TCS", "contribution": 980.0}
            ],
            top_detractors=[
                {"symbol": "HDFC", "contribution": -320.0}
            ],
            portfolio_beta=0.85,
            correlation_with_benchmark=0.78,
            risk_score=6.5
        )
        
        return analytics
        
    except Exception as e:
        logger.error(f"Failed to get analytics for portfolio {portfolio_id}: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={"error": "fetch_failed", "message": f"Failed to fetch analytics: {str(e)}"}
        )


# Background task functions
async def update_portfolio_metrics(
    portfolio_id: int,
    symbol: str,
    transaction_type: TransactionType,
    quantity: int,
    price: float
):
    """
    Background task to update portfolio holdings and metrics after a transaction.
    
    This would typically update:
    - Holdings table with new quantities and average prices
    - Portfolio cash balance
    - Performance metrics
    """
    try:
        logger.info(f"Updating metrics for portfolio {portfolio_id} after {transaction_type} of {quantity} {symbol} at {price}")
        
        # Mock implementation - in production, this would:
        # 1. Update holdings table
        # 2. Recalculate average prices
        # 3. Update cash balance
        # 4. Refresh performance metrics
        # 5. Update risk calculations
        
        await asyncio.sleep(0.1)  # Simulate processing time
        logger.info(f"Completed metrics update for portfolio {portfolio_id}")
        
    except Exception as e:
        logger.error(f"Failed to update portfolio metrics: {str(e)}")


# Health check endpoint
@router.get("/health", include_in_schema=False)
async def portfolio_health_check():
    """Health check endpoint for portfolio service."""
    return {"status": "healthy", "service": "portfolio", "timestamp": datetime.utcnow()} 